# 								树

## <span style='color:red;'>1、B树</span>

![1586256764592](E:\Typora笔记\assets\1586256764592.png)

### （1）特点

1.根结点至少有两个子女。

2.除根节点以外的节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m（m/2向上取余，m代表该树是几路树）

3.所有的叶子结点都位于同一层。

4.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

###  （2） 查找过程

 1、先让待查找的关键字和节点关键字比较，若相等，成功，若不相等，则看key在哪个范围内，然后去对应子树查找



## <span style='color:red;'>2、B+树</span>

## ![1586258098684](E:\Typora笔记\assets\1586258098684.png)

### 1、特点

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），**每个元素不保存数据，只用来索引，所有数据都保存在叶子节点**。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

***补充：在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

### 2、B+树相对B树的优点

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。范围查找时，B+树需要中序遍历，B+树只需要自顶向下索引到叶子节点，然后利用叶子节点的指针进行搜索即可。

## <span style='color:red;'>3、二叉查找树（二叉排序树、二叉搜索树）</span>

![1586261059894](E:\Typora笔记\assets\1586261059894.png)

### 1、特点

1.左子树上所有结点的值均小于或等于它的根结点的值。

2.右子树上所有结点的值均大于或等于它的根结点的值。

3.左、右子树也分别为二叉排序树。

### 2、插入操作

二叉排序树中有该元素则不插入，否则插入 insert(int elements)   递归解决

### 3、删除操作

分三种情况

1、删除的节点只有左子树，没有右子树，则直接将该节点的父节点指向该节点的左子树节点即可（删除值为5的节点）

![1589434758328](E:\Typora笔记\数据结构和算法\assets\1589434758328.png)

2、删除的节点只有右子树，没有左子树，则直接将该节点的父节点指向该节点的右子树即可（删除值为20的节点）

![1589434893347](E:\Typora笔记\数据结构和算法\assets\1589434893347.png)

3、删除的节点不仅有左子树还有右子树

​		①该情况下的第一种情况(q！=p的情况，重接右子树)  30为要被删除的数

![1589436616832](E:\Typora笔记\数据结构和算法\assets\1589436616832.png)

​		②该情况下的第二种情况（q==p的情况下，重接左子树）

![1589437325586](E:\Typora笔记\数据结构和算法\assets\1589437325586.png)

## <span style='color:red;'>4、平衡二叉树</span>（二叉排序树加入了平衡的过程）

### 1、定义

所有节点的左右子树的高度差不大于1（平衡因子为1的情况下），节点高度的定义（该节点到叶子节点的距离），节点是从叶子节点往上定义，深度是从根节点往下数的。

### 2、失衡情况分类及解决

1、左左失衡，解决办法，右旋，将失衡点绕左子树顺时针旋转，失衡点变成左子树的右子树

![1589289479426](E:\Typora笔记\数据结构和算法\assets\1589289479426.png)

右旋后的结果

![1589289819376](E:\Typora笔记\数据结构和算法\assets\1589289819376.png)

2、右右失衡，左旋转，将失衡点绕着他的右子树逆时针旋转，失衡点变成他的右子树的左子树

![1589290194099](E:\Typora笔记\数据结构和算法\assets\1589290194099.png)

左旋后的结果

![1589290268182](E:\Typora笔记\数据结构和算法\assets\1589290268182.png)

3、右左失衡（单纯的左单旋和右单旋已经不能满足需求），需要先右旋，再左旋

![1589290662186](E:\Typora笔记\数据结构和算法\assets\1589290662186.png)

单纯的右左失衡

右旋

![1589291591992](E:\Typora笔记\数据结构和算法\assets\1589291591992.png)

左旋

![1589291651699](E:\Typora笔记\数据结构和算法\assets\1589291651699.png)

4、左右失衡

![1589291845997](E:\Typora笔记\数据结构和算法\assets\1589291845997.png)

左旋

![1589291903055](E:\Typora笔记\数据结构和算法\assets\1589291903055.png)

右旋

![1589291944516](E:\Typora笔记\数据结构和算法\assets\1589291944516.png)





## <span style='color:red;'>5、红黑树</span>

红黑树是一种**自平衡**的**二叉查找树**

博客地址：<https://blog.csdn.net/qq_26222859/article/details/47266965>  （ctrl+左键）

![1586260622210](E:\Typora笔记\assets\1586260622210.png)

### 1、特点

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

### 2、红黑树被破坏之后的处理办法

1、向红黑树插入值为21的红色节点

![1586263850380](E:\Typora笔记\assets\1586263850380.png)

由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。使用的重要方法（左旋、右旋、变色如下图）

**左旋**:是以节点的"右分支"为轴，进行逆时针旋转。逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。

![1586264675644](E:\Typora笔记\assets\1586264675644.png)

**右旋**：是以节点的“左分支"为轴，进行顺时针旋转。顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。

![1586266088787](E:\Typora笔记\assets\1586266088787.png)

变色无法解决问题，把节点13看做X，把节点17看做Y，像刚才的示意图那样进行左旋转,左旋之后的结果如图所示：

![1586266750476](E:\Typora笔记\assets\1586266750476.png)

由于根节点必须是黑色节点，所以需要变色，变色结果如下(还没有结束，因为其中两条路径(17 -> 8 -> 6 -> NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。)

![1586266834550](E:\Typora笔记\assets\1586266834550.png)

这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行右旋转：

![1586267087474](E:\Typora笔记\assets\1586267087474.png)

最后根据规则来进行变色：

![1586267215233](E:\Typora笔记\assets\1586267215233.png)

## 6、前缀树

博客原文：<https://blog.csdn.net/weixin_39778570/article/details/81990417>

## 7、线段树

博客原文:<https://blog.csdn.net/huangzihaoal/article/details/81813454>